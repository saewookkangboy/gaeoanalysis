# GAEO Analysis - Constitution (헌법)

이 문서는 GAEO Analysis 프로젝트의 기본 원칙, 코딩 스타일, 아키텍처 결정을 정의합니다. 모든 개발 작업은 이 Constitution을 준수해야 합니다.

**최종 업데이트**: 2025년 1월  
**버전**: 1.0

---

## 📋 목차

1. [프로젝트 개요](#프로젝트-개요)
2. [코드 품질 원칙](#코드-품질-원칙)
3. [아키텍처 원칙](#아키텍처-원칙)
4. [보안 원칙](#보안-원칙)
5. [성능 원칙](#성능-원칙)
6. [코딩 컨벤션](#코딩-컨벤션)
7. [문서화 원칙](#문서화-원칙)
8. [테스트 원칙](#테스트-원칙)
9. [Git 워크플로우](#git-워크플로우)

---

## 프로젝트 개요

### 프로젝트 목적
GAEO Analysis는 생성형 AI 검색 환경(GEO/AEO)에 최적화된 콘텐츠 분석 및 개선 가이드를 제공하는 웹 애플리케이션입니다.

### 핵심 가치
- **AI 검색 최적화**: ChatGPT, Perplexity, Gemini, Claude 등 다양한 AI 모델에서 콘텐츠가 인용될 확률 분석
- **종합 점수 평가**: AEO, GEO, SEO 점수를 통합하여 콘텐츠 품질 평가
- **실시간 개선 가이드**: AI Agent를 통한 대화형 개선 방안 제시
- **사용자 중심 설계**: 다크 모드, 반응형 디자인, 직관적인 UI/UX

---

## 코드 품질 원칙

### TypeScript 사용
- ✅ **엄격 모드 필수**: `tsconfig.json`에서 `strict: true` 설정
- ✅ **타입 안정성 최우선**: `any` 타입 사용 금지 (예외: 외부 라이브러리 타입 정의 불가능한 경우)
- ✅ **명시적 타입 정의**: 함수 매개변수, 반환값, 변수에 타입 명시
- ✅ **타입 추론 활용**: 명확한 경우 타입 추론 활용 (과도한 타입 명시 지양)

### 코드 품질
- ✅ **ESLint 규칙 준수**: 프로젝트의 ESLint 설정 준수
- ✅ **함수/컴포넌트 단일 책임 원칙**: 하나의 함수/컴포넌트는 하나의 책임만 가짐
- ✅ **에러 핸들링 필수**: 모든 비동기 작업과 외부 API 호출에 에러 핸들링 포함
- ✅ **DRY 원칙**: 코드 중복 최소화, 재사용 가능한 함수/컴포넌트 생성
- ✅ **가독성 우선**: 복잡한 로직은 주석과 설명 추가

### 코드 구조
- ✅ **모듈화**: 관련 기능은 별도 모듈로 분리
- ✅ **의존성 최소화**: 불필요한 의존성 추가 지양
- ✅ **순환 참조 방지**: 모듈 간 순환 참조 금지

---

## 아키텍처 원칙

### Next.js App Router
- ✅ **App Router 사용**: Pages Router 대신 App Router 사용
- ✅ **Server Components 우선**: 기본적으로 Server Components 사용, 필요한 경우에만 Client Components 사용
- ✅ **Route Handler 패턴**: API 엔드포인트는 `app/api/[route]/route.ts` 형식 사용

### 디렉토리 구조
```
gaeo-analysis/
├── app/                    # Next.js App Router
│   ├── api/               # API 라우트
│   ├── [page]/            # 페이지 라우트
│   └── layout.tsx         # 레이아웃
├── components/            # React 컴포넌트
├── lib/                   # 유틸리티 및 비즈니스 로직
├── types/                 # TypeScript 타입 정의
├── scripts/               # 유틸리티 스크립트
├── database/              # 데이터베이스 스키마
└── memory/                # 프로젝트 헌법 및 명세서
```

### 컴포넌트 구조
- ✅ **Server Components 우선**: 기본적으로 Server Components 사용
- ✅ **Client Components 명시**: `'use client'` 지시어로 명시
- ✅ **컴포넌트 분리**: 재사용 가능한 컴포넌트는 `components/` 디렉토리
- ✅ **페이지 컴포넌트**: 페이지별 컴포넌트는 `app/[page]/page.tsx`

### 비즈니스 로직
- ✅ **로직 분리**: 비즈니스 로직은 `lib/` 디렉토리에 분리
- ✅ **데이터베이스 추상화**: 데이터베이스 접근은 헬퍼 함수로 추상화 (`lib/db-helpers.ts`)
- ✅ **API 유틸리티**: 공통 API 로직은 `lib/api-utils.ts`에 분리
- ✅ **에러 처리**: 표준화된 에러 처리 (`lib/api-utils.ts`)

### 데이터베이스
- ✅ **트랜잭션 사용**: 모든 쓰기 작업은 트랜잭션으로 보호
- ✅ **인덱스 최적화**: 자주 조회되는 컬럼에 인덱스 추가
- ✅ **마이그레이션 시스템**: 스키마 변경은 마이그레이션으로 관리
- ✅ **데이터 정합성**: 외래 키 제약 조건, 체크 제약 조건 사용

---

## 보안 원칙

### 입력 검증
- ✅ **Zod 스키마 사용**: 모든 사용자 입력은 Zod 스키마로 검증
- ✅ **URL Sanitization**: URL 입력은 검증 및 sanitization
- ✅ **텍스트 Sanitization**: XSS 방지를 위한 텍스트 sanitization
- ✅ **타입 검증**: 런타임 타입 검증 (Zod)

### 레이트 리미팅
- ✅ **IP별 제한**: IP 주소별 요청 제한
- ✅ **사용자별 제한**: 인증된 사용자별 요청 제한
- ✅ **엔드포인트별 제한**: 엔드포인트별 적절한 제한 설정

### 인증 및 권한
- ✅ **NextAuth.js 사용**: 인증은 NextAuth.js 사용
- ✅ **Firebase Auth 통합**: Firebase Authentication 통합
- ✅ **세션 관리**: 안전한 세션 관리
- ✅ **권한 검증**: API 엔드포인트에서 사용자 권한 검증

### 보안 헤더
- ✅ **자동 설정**: `lib/headers.ts`에서 보안 헤더 자동 설정
- ✅ **CORS 설정**: 적절한 CORS 설정
- ✅ **XSS 방지**: X-Content-Type-Options, X-XSS-Protection 헤더
- ✅ **CSRF 방지**: 적절한 CSRF 방지 메커니즘

### 환경 변수
- ✅ **민감 정보 보호**: API 키, 시크릿은 환경 변수로 관리
- ✅ **환경별 설정**: 개발/프로덕션 환경별 설정 분리
- ✅ **환경 변수 검증**: 필수 환경 변수 검증 (`scripts/check-env.ts`)

---

## 성능 원칙

### 캐싱
- ✅ **메모리 캐싱**: 동일 URL 재분석 시 캐시 활용 (`lib/cache.ts`)
- ✅ **캐시 TTL**: 적절한 캐시 TTL 설정 (24시간)
- ✅ **캐시 무효화**: 데이터 변경 시 캐시 무효화

### 데이터베이스 최적화
- ✅ **인덱스 활용**: 자주 조회되는 컬럼에 인덱스 추가
- ✅ **복합 인덱스**: 복합 쿼리에 복합 인덱스 사용
- ✅ **쿼리 최적화**: 불필요한 조인, 서브쿼리 최소화
- ✅ **WAL 모드**: SQLite WAL 모드 활성화

### 리소스 최적화
- ✅ **이미지 최적화**: Next.js Image 컴포넌트 사용
- ✅ **레이지 로딩**: 필요 시에만 리소스 로드
- ✅ **코드 스플리팅**: Next.js 자동 코드 스플리팅 활용

### 네트워크 최적화
- ✅ **재시도 로직**: 네트워크 실패 시 Exponential Backoff 재시도
- ✅ **타임아웃 설정**: 적절한 타임아웃 설정
- ✅ **에러 복구**: 자동 재시도 및 에러 복구 메커니즘

---

## 코딩 컨벤션

### 네이밍 규칙
- ✅ **컴포넌트**: PascalCase (예: `ScoreCard.tsx`, `AIAgent.tsx`)
- ✅ **함수/변수**: camelCase (예: `calculateScore`, `userAnalyses`)
- ✅ **상수**: UPPER_SNAKE_CASE (예: `MAX_RETRY_COUNT`, `CACHE_TTL`)
- ✅ **타입/인터페이스**: PascalCase (예: `AnalysisResult`, `UserData`)
- ✅ **파일명**: 컴포넌트는 PascalCase, 유틸리티는 kebab-case 또는 camelCase

### 파일 구조 규칙
- ✅ **한 파일에 하나의 주요 export**: 기본 export는 하나만
- ✅ **관련 타입**: 타입은 같은 파일 또는 `types/` 디렉토리
- ✅ **유틸리티 함수**: `lib/` 디렉토리에 분리
- ✅ **컴포넌트**: `components/` 디렉토리에 분리

### 함수 작성 규칙
- ✅ **함수 길이**: 함수는 50줄 이내 (복잡한 경우 분리)
- ✅ **매개변수**: 매개변수는 5개 이내 (객체로 그룹화)
- ✅ **반환값**: 명확한 반환 타입 정의
- ✅ **에러 처리**: 모든 비동기 함수에 에러 처리

### 주석 작성 규칙
- ✅ **복잡한 로직**: 복잡한 알고리즘은 주석 추가
- ✅ **JSDoc**: 공개 함수는 JSDoc 주석
- ✅ **TODO 주석**: 임시 코드는 TODO 주석과 함께
- ✅ **의미 있는 주석**: 코드 자체로 설명 가능하면 주석 생략

---

## 문서화 원칙

### 코드 문서화
- ✅ **JSDoc 주석**: 공개 함수, 클래스, 인터페이스에 JSDoc 주석
- ✅ **타입 설명**: 복잡한 타입은 설명 추가
- ✅ **API 주석**: API 엔드포인트에 요청/응답 스키마 주석

### 프로젝트 문서화
- ✅ **README.md**: 프로젝트 개요, 설치 방법, 사용법
- ✅ **ARCHITECTURE.md**: 시스템 아키텍처, 기술 스택
- ✅ **기능별 문서**: 주요 기능별 상세 문서 (예: `ALGORITHM_LEARNING_SYSTEM.md`)
- ✅ **명세서**: 새 기능 개발 시 명세서 작성 (`specs/` 디렉토리)

### 문서 업데이트
- ✅ **최신 상태 유지**: 코드 변경 시 관련 문서 업데이트
- ✅ **버전 관리**: 문서 버전 관리
- ✅ **명확한 예시**: 문서에 실제 사용 예시 포함

---

## 테스트 원칙

### 테스트 전략
- ✅ **단위 테스트**: 비즈니스 로직은 단위 테스트 작성
- ✅ **통합 테스트**: API 엔드포인트는 통합 테스트 작성
- ✅ **E2E 테스트**: 주요 사용자 플로우는 E2E 테스트 작성

### 테스트 작성 규칙
- ✅ **테스트 명확성**: 테스트 이름은 명확하게 작성
- ✅ **테스트 격리**: 각 테스트는 독립적으로 실행 가능
- ✅ **테스트 커버리지**: 핵심 비즈니스 로직은 높은 커버리지 목표

---

## Git 워크플로우

### 커밋 메시지 규칙
- ✅ **Conventional Commits**: Conventional Commits 형식 사용
- ✅ **타입 접두사**: `feat:`, `fix:`, `refactor:`, `docs:`, `style:`, `chore:` 사용
- ✅ **명확한 설명**: 커밋 메시지는 변경 사항을 명확히 설명

### 커밋 메시지 예시
```
feat: 새로운 기능 추가
fix: 버그 수정
refactor: 코드 리팩토링
docs: 문서 업데이트
style: 스타일 변경
chore: 기타 작업 (의존성 업데이트 등)
```

### 브랜치 전략
- ✅ **main 브랜치**: 프로덕션 배포 브랜치
- ✅ **기능 브랜치**: 새 기능 개발 시 브랜치 생성 (선택사항)
- ✅ **자동 푸시**: 작업 완료 시 자동 Git 푸시 (`.cursorrules`에 정의됨)

### 자동 푸시 프로세스
1. 작업 완료 후 변경사항 확인
2. 모든 변경사항 스테이징 (`git add .`)
3. 의미있는 커밋 메시지로 커밋
4. 원격 저장소로 푸시 (`git push`)

---

## 예외 및 특수 상황

### 예외 처리
- ✅ **명시적 예외**: 예외 상황은 명시적으로 처리
- ✅ **에러 로깅**: 에러는 적절히 로깅
- ✅ **사용자 친화적 메시지**: 사용자에게 친화적인 에러 메시지 제공

### 성능 vs 가독성
- ✅ **가독성 우선**: 성능이 크게 차이 나지 않으면 가독성 우선
- ✅ **성능 최적화**: 성능 병목 지점은 최적화
- ✅ **프로파일링**: 성능 최적화 전 프로파일링 수행

### 레거시 코드
- ✅ **점진적 개선**: 레거시 코드는 점진적으로 개선
- ✅ **문서화**: 레거시 코드는 문서화하여 이해도 향상
- ✅ **리팩토링**: 기회가 있을 때 리팩토링

---

## Constitution 준수

### 검토 프로세스
- ✅ **코드 리뷰**: 모든 코드 변경은 Constitution 준수 여부 검토
- ✅ **자동 검증**: ESLint, TypeScript 컴파일러로 자동 검증
- ✅ **수동 검토**: 복잡한 변경사항은 수동 검토

### Constitution 업데이트
- ✅ **버전 관리**: Constitution 변경 시 버전 업데이트
- ✅ **의견 수렴**: 팀원과 논의 후 Constitution 업데이트
- ✅ **문서화**: Constitution 변경 사항 문서화

---

## 참고 자료

- [프로젝트 README](./README.md)
- [프로젝트 아키텍처](./ARCHITECTURE.md)
- [Spec-Kit 체크리스트](./SPEC_KIT_IMPLEMENTATION_CHECKLIST.md)
- [Next.js 공식 문서](https://nextjs.org/docs)
- [TypeScript 공식 문서](https://www.typescriptlang.org/docs/)

---

**Constitution 버전**: 1.0  
**최종 업데이트**: 2025년 1월  
**유지보수**: 프로젝트 팀

